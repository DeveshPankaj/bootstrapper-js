<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Xterm</title>
  <link rel="stylesheet" href="https://unpkg.com/xterm/css/xterm.css">
  <style>
    * {
      margin: 0;
      padding: 0;
    }
    html, body {
      height: 100%;
      width: 100%;
      display: flex;
    }
    #terminal {
      flex: 1;
      height: 100vh;
      width: 100vw;
    }
    .xterm {
      width: 100%;
      height: 100%;
      font-family: 'Courier New', Courier, monospace;
      font-size: 14px;
      line-height: 1;
      background-color: black;
    }
  </style>
</head>
<body>
  <div id="terminal"></div>

  <script type="module">
    import 'https://unpkg.com/xterm/lib/xterm.js';

    class TerminalManager {
      constructor() {
        this.terminal = new Terminal({
          cursorBlink: true,
          convertEol: true,
          fontSize: 14,
          fontFamily: 'Courier New',
          theme: {
            background: '#000000',
            foreground: '#00FF00',
          }
        });
        this.context = {
          pwd: '/home/user1',
          PATH: '/bin:/usr/bin',
          USER: 'root'
        };
        this.commandHistory = [];
        this.historyIndex = -1;
        this.inputBuffer = '';
        this.neofetchMessages = this.initializeMessages();
        this.fs = platform.host.getFS();
        this.files = this.fs.readdirSync(this.context.pwd);
      }

      initializeTerminal() {
        this.terminal.open(document.getElementById('terminal'));
        this.resizeTerminal();
        this.handleTerminalInput();
        this.processCommand('info');
        window.addEventListener('resize', () => this.resizeTerminal());
      }

      resizeTerminal() {
        this.terminal.resize(Math.floor(window.innerWidth / 9), Math.floor(window.innerHeight / 18));
      }

      handleTerminalInput() {
        this.terminal.onData(data => this.processInput(data));
      }

      processInput(data) {
        if (data === '\r') {
          this.processEnterKey();
        } else if (data === '\u007F') {
          this.processBackspace();
        } else if (data === '\u001b[A') {
          this.processUpArrow();
        } else if (data === '\u001b[B') {
          this.processDownArrow();
        } else if (data === '\u000C') {
          this.clearTerminal();
        } else {
          this.inputBuffer += data;
          this.terminal.write(data);
        }
      }

      processEnterKey() {
        this.terminal.write('\r\n');
        if (this.inputBuffer.trim() !== '') {
          this.processCommand(this.inputBuffer.trim());
          this.commandHistory.push(this.inputBuffer.trim());
          this.appendHistory(this.inputBuffer.trim());
          this.historyIndex = this.commandHistory.length;
        }
        this.inputBuffer = '';
        this.terminal.write('\r\n'); // Ensure the cursor moves to the next empty line
        this.displayPrompt();
      }
      
      appendHistory(command) {
        const historyFile = `${this.context.pwd}/.bash_history`;
        const fs = this.fs
        // Append the command to the history file
        if (fs.existsSync(historyFile)) {
          fs.appendFileSync(historyFile, `${command}\n`);
        } else {
          fs.writeFileSync(historyFile, `${command}\n`);
        }
      }


      processBackspace() {
        if (this.inputBuffer.length > 0) {
          this.inputBuffer = this.inputBuffer.slice(0, -1);
          this.terminal.write('\b \b');
        }
      }

      processUpArrow() {
        if (this.historyIndex > 0) {
          this.historyIndex--;
          this.inputBuffer = this.commandHistory[this.historyIndex];
          this.updateCommandLine();
        }
      }

      processDownArrow() {
        if (this.historyIndex < this.commandHistory.length - 1) {
          this.historyIndex++;
          this.inputBuffer = this.commandHistory[this.historyIndex];
          this.updateCommandLine();
        } else {
          this.historyIndex = this.commandHistory.length;
          this.inputBuffer = '';
          this.updateCommandLine();
        }
      }

      updateCommandLine() {
        this.terminal.write(`\r\x1b[32mroot\x1b[0m\x1b[36m@pankajdevesh.com\x1b[0m: \x1b[33m~${this.context.pwd}$\x1b[0m ${' '.repeat(this.inputBuffer.length)}\r`);
        this.displayPrompt();
      }

      clearTerminal() {
        this.terminal.write('\x1b[2J\x1b[H');
        this.displayPrompt();
      }

      displayPrompt() {
        this.terminal.write(`\x1b[32mroot\x1b[0m\x1b[36m@pankajdevesh.com\x1b[0m: \x1b[33m~${this.context.pwd}$\x1b[0m ${this.inputBuffer}`);
      }

      processCommand(command) {
        const cmdArgs = command.split(' ');
        const commandFile = this.findCommandFile(cmdArgs[0]);

        if (commandFile) {
          platform.register('terminal', this.terminal);
          platform.register('context', this.context);
          platform.host.exec(platform, commandFile, this.context.pwd, ...cmdArgs.slice(1));
        } else {
          this.handleInternalCommands(cmdArgs);
        }
      }

      findCommandFile(command) {
        let commandFile = '';
        const binDirs = this.context.PATH.split(':');
        for (const dir of binDirs) {
          const _commandFile = `${dir}/${command}.run`;
          if (!this.fs.existsSync(_commandFile)) continue;
          commandFile = _commandFile;
          break;
        }
        return commandFile;
      }

      handleInternalCommands(cmdArgs) {
        switch (cmdArgs[0]) {
          case 'cd':
            this.changeDirectory(cmdArgs);
            break;
          case 'edit':
            this.editFile(cmdArgs);
            break;
          default:
            this.terminal.write(`Command not found: ${cmdArgs[0]}\r\n`);
            break;
        }
      }

      changeDirectory(cmdArgs) {
        if (cmdArgs.length < 2) {
          this.terminal.write('cd: missing operand\r\n');
        } else {
          let newDir = cmdArgs[1];
          newDir = this.resolveDirectory(newDir);
          try {
            if (this.fs.statSync(newDir).isDirectory()) {
              this.context.pwd = newDir;
              this.files = this.fs.readdirSync(this.context.pwd);
            } else {
              this.terminal.write(`cd: ${newDir}: Not a directory\r\n`);
            }
          } catch (err) {
            this.terminal.write(`cd: ${newDir}: No such file or directory\r\n`);
          }
        }
      }

      resolveDirectory(dir) {
        if (dir === '..') {
          const parentDir = this.context.pwd.split('/').slice(0, -1).join('/');
          return parentDir || '/';
        } else if (!dir.startsWith('/')) {
          return `${this.context.pwd}/${dir}`;
        }
        return dir;
      }

      editFile(cmdArgs) {
        if (cmdArgs.length < 2) {
          this.terminal.write('edit: missing operand\r\n');
        } else {
          // Handle edit logic here
        }
      }

      initializeMessages() {
        return [
          this.createNeofetchMessage('Linux Terminal', 'Linux x86_64', 'xterm.js', '10m', '1024', '512MB / 2048MB', 'Intel i5'),
          this.createNeofetchMessage('Mac Terminal', 'macOS Monterey', 'zsh', '5h 30m', '67', '8GB / 16GB', 'M1 Pro'),
          this.createNeofetchMessage('Linux Terminal', 'Ubuntu 22.04', 'bash', '1h 45m', '1500', '4GB / 16GB', 'Intel i7'),
          this.createNeofetchMessage('Windows Terminal', 'Windows 11', 'PowerShell', '2d 12h', '112', '16GB / 32GB', 'Ryzen 7'),
          this.createNeofetchMessage('Fedora Terminal', 'Fedora 36', 'fish', '3h 20m', '980', '2GB / 8GB', 'AMD Ryzen 5'),
          this.createNeofetchMessage('Linux Terminal ðŸ˜Ž', 'Ubuntu 22.04 ðŸ§', 'bash ðŸš', '1h 45m â³', '1500 ðŸ“¦', '4GB / 16GB ðŸ§ ', 'Intel i7 ðŸ’»'),
          this.createCustomMessage('Pankaj Devesh', 'Senior Software Engineer', 'TypeScript, Python', 'pankajdevesh.com', '5 years', 'Fullstack Development', 'Microservices, CLI'),
          this.createCustomMessage('Pankaj Devesh\'s Cow', 'Senior Software Engineer', 'TypeScript, Python', 'Hello World!', 'Mooing about Code!', 'Senior Software Engineer', 'TypeScript, Python')
        ];
      }

      createNeofetchMessage(name, os, shell, uptime, packages, memory, cpu) {
        return `\x1b[33m        .--.                  \x1b[0m\x1b[34m${name}\x1b[0m
\x1b[33m       |o_o |                 \x1b[34mOS: ${os}\x1b[0m
\x1b[33m       |:_/ |                 \x1b[34mShell: ${shell}\x1b[0m
\x1b[33m      //   \\ \\                \x1b[34mUptime: ${uptime}\x1b[0m
\x1b[33m     (|     | )               \x1b[34mPackages: ${packages}\x1b[0m
\x1b[33m    /'\\_   _/\`\\              \x1b[34mMemory: ${memory}\x1b[0m
\x1b[33m    \\___)=(___/               \x1b[34mCPU: ${cpu}\x1b[0m\r\n`;
      }

      createCustomMessage(name, role, techStack, website, experience, specialty, areaOfFocus) {
        return `\x1b[33m        .--.                  \x1b[0m\x1b[34m${name}\x1b[0m
\x1b[33m       |o_o |                 \x1b[34mRole: ${role}\x1b[0m
\x1b[33m       |:_/ |                 \x1b[34mTech Stack: ${techStack}\x1b[0m
\x1b[33m      //   \\ \\                \x1b[34mWebsite: ${website}\x1b[0m
\x1b[33m     (|     | )               \x1b[34mExperience: ${experience}\x1b[0m
\x1b[33m    /'\\_   _/\`\\              \x1b[34mSpecialty: ${specialty}\x1b[0m
\x1b[33m    \\___)=(___/               \x1b[34mArea of Focus: ${areaOfFocus}\x1b[0m\r\n`;
      }
    }

    const terminalManager = new TerminalManager();
    terminalManager.initializeTerminal();
  </script>
</body>
</html>
